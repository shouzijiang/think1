# 后端开发快速指南

## 一、核心功能实现要点

### 1. 微信登录流程

```
前端调用 uni.login() 
  ↓
获取 code
  ↓
调用后端接口 /auth/wechat/login，传递 code
  ↓
后端调用微信接口获取 openid
  ↓
后端查询/创建用户
  ↓
后端生成 JWT token 返回给前端
  ↓
前端保存 token，后续请求携带 token
```

### 2. 订阅消息发送流程

```
后端定时任务（每5-10分钟执行一次）
  ↓
查询所有启用提醒的用户
  ↓
检查用户是否在工作时间内
  ↓
检查是否到了提醒时间
  ↓
查询用户是否授权了订阅消息
  ↓
调用微信接口发送订阅消息
  ↓
记录发送日志
```

## 二、PHP 核心代码示例

### 1. 微信登录接口实现

```php
<?php
// api/auth/wechat/login.php

require_once '../config.php';
require_once '../utils/jwt.php';
require_once '../utils/db.php';

header('Content-Type: application/json; charset=utf-8');

// 获取请求数据
$input = json_decode(file_get_contents('php://input'), true);
$code = $input['code'] ?? '';

if (empty($code)) {
    echo json_encode([
        'code' => 400,
        'message' => '参数错误：code不能为空'
    ]);
    exit;
}

// 配置信息
$appid = WECHAT_APPID;
$secret = WECHAT_SECRET;

// 调用微信接口获取 openid
$url = "https://api.weixin.qq.com/sns/jscode2session?appid={$appid}&secret={$secret}&js_code={$code}&grant_type=authorization_code";

$ch = curl_init();
curl_setopt($ch, CURLOPT_URL, $url);
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);
$response = curl_exec($ch);
curl_close($ch);

$wechat_data = json_decode($response, true);

// 检查微信接口返回
if (isset($wechat_data['errcode'])) {
    echo json_encode([
        'code' => 402,
        'message' => '微信登录失败: ' . ($wechat_data['errmsg'] ?? '未知错误')
    ]);
    exit;
}

$openid = $wechat_data['openid'] ?? '';
$session_key = $wechat_data['session_key'] ?? '';

if (empty($openid)) {
    echo json_encode([
        'code' => 402,
        'message' => '获取openid失败'
    ]);
    exit;
}

// 查询或创建用户
$db = getDB();
$stmt = $db->prepare("SELECT * FROM users WHERE openid = ?");
$stmt->execute([$openid]);
$user = $stmt->fetch(PDO::FETCH_ASSOC);

if (!$user) {
    // 创建新用户
    $stmt = $db->prepare("INSERT INTO users (openid, created_at, updated_at) VALUES (?, NOW(), NOW())");
    $stmt->execute([$openid]);
    $user_id = $db->lastInsertId();
    
    // 创建默认设置
    $stmt = $db->prepare("INSERT INTO user_settings (user_id, enabled, work_start_time, work_end_time, remind_interval) VALUES (?, 1, '09:00', '18:00', 2)");
    $stmt->execute([$user_id]);
    
    $user = [
        'id' => $user_id,
        'openid' => $openid,
        'nickname' => null,
        'avatar' => null
    ];
} else {
    $user_id = $user['id'];
}

// 生成 JWT token
$token = generateJWT([
    'user_id' => $user_id,
    'openid' => $openid
]);

// 返回结果
echo json_encode([
    'code' => 200,
    'message' => '登录成功',
    'data' => [
        'token' => $token,
        'openid' => $openid,
        'user_id' => $user_id,
        'nickname' => $user['nickname'],
        'avatar' => $user['avatar'],
        'expires_in' => 7200
    ]
]);
```

### 2. 提交打卡接口实现

```php
<?php
// api/punch/submit.php

require_once '../config.php';
require_once '../utils/auth.php';
require_once '../utils/db.php';

header('Content-Type: application/json; charset=utf-8');

// 验证 token
$user = verifyToken();
if (!$user) {
    echo json_encode([
        'code' => 401,
        'message' => '未授权，请重新登录'
    ]);
    exit;
}

// 获取参数
$input = json_decode(file_get_contents('php://input'), true);
$timestamp = $input['timestamp'] ?? (time() * 1000);

// 保存打卡记录
$db = getDB();
$stmt = $db->prepare("INSERT INTO punch_records (user_id, timestamp, created_at) VALUES (?, ?, NOW())");
$stmt->execute([$user['user_id'], $timestamp]);
$record_id = $db->lastInsertId();

// 计算统计数据
$today_start = strtotime('today') * 1000;
$today_end = strtotime('tomorrow') * 1000 - 1;

// 今日打卡次数
$stmt = $db->prepare("SELECT COUNT(*) as count FROM punch_records WHERE user_id = ? AND timestamp >= ? AND timestamp < ?");
$stmt->execute([$user['user_id'], $today_start, $today_end]);
$today_count = $stmt->fetch(PDO::FETCH_ASSOC)['count'];

// 总打卡次数
$stmt = $db->prepare("SELECT COUNT(*) as count FROM punch_records WHERE user_id = ?");
$stmt->execute([$user['user_id']]);
$total_count = $stmt->fetch(PDO::FETCH_ASSOC)['count'];

// 计算连续天数
$streak_days = calculateStreakDays($db, $user['user_id']);

// 返回结果
echo json_encode([
    'code' => 200,
    'message' => '打卡成功',
    'data' => [
        'record_id' => $record_id,
        'timestamp' => $timestamp,
        'today_count' => (int)$today_count,
        'total_count' => (int)$total_count,
        'streak_days' => $streak_days
    ]
]);

// 计算连续打卡天数
function calculateStreakDays($db, $user_id) {
    $stmt = $db->prepare("
        SELECT DATE(FROM_UNIXTIME(timestamp/1000)) as date 
        FROM punch_records 
        WHERE user_id = ? 
        GROUP BY DATE(FROM_UNIXTIME(timestamp/1000))
        ORDER BY date DESC
    ");
    $stmt->execute([$user_id]);
    $dates = $stmt->fetchAll(PDO::FETCH_COLUMN);
    
    if (empty($dates)) {
        return 0;
    }
    
    $streak = 0;
    $today = date('Y-m-d');
    $check_date = $today;
    
    foreach ($dates as $date) {
        if ($date === $check_date) {
            $streak++;
            $check_date = date('Y-m-d', strtotime($check_date . ' -1 day'));
        } else {
            break;
        }
    }
    
    return $streak;
}
```

### 3. 发送订阅消息定时任务

```php
<?php
// cron/send_remind.php

require_once '../config.php';
require_once '../utils/db.php';
require_once '../utils/wechat.php';

// 获取微信 access_token
$access_token = getWechatAccessToken();

// 查询所有启用提醒的用户
$db = getDB();
$stmt = $db->prepare("
    SELECT u.id, u.openid, us.work_start_time, us.work_end_time, us.remind_interval, us.last_remind_time
    FROM users u
    INNER JOIN user_settings us ON u.id = us.user_id
    WHERE us.enabled = 1
");
$stmt->execute();
$users = $stmt->fetchAll(PDO::FETCH_ASSOC);

$now = time() * 1000; // 当前时间戳（毫秒）

foreach ($users as $user) {
    // 检查是否在工作时间内
    if (!isWorkTime($user['work_start_time'], $user['work_end_time'])) {
        continue;
    }
    
    // 检查是否到了提醒时间
    $last_remind_time = $user['last_remind_time'] ?? 0;
    $interval_ms = $user['remind_interval'] * 60 * 60 * 1000;
    
    if ($now - $last_remind_time < $interval_ms) {
        continue; // 还没到提醒时间
    }
    
    // 查询用户是否授权了订阅消息
    $stmt = $db->prepare("
        SELECT template_id FROM user_subscribes 
        WHERE user_id = ? AND subscribe_status = 'accept' 
        ORDER BY updated_at DESC 
        LIMIT 1
    ");
    $stmt->execute([$user['id']]);
    $subscribe = $stmt->fetch(PDO::FETCH_ASSOC);
    
    if (!$subscribe) {
        continue; // 用户未授权订阅消息
    }
    
    $template_id = $subscribe['template_id'];
    
    // 发送订阅消息
    $result = sendSubscribeMessage($access_token, $user['openid'], $template_id);
    
    // 更新最后提醒时间
    if ($result['success']) {
        $stmt = $db->prepare("UPDATE user_settings SET last_remind_time = ? WHERE user_id = ?");
        $stmt->execute([$now, $user['id']]);
        
        // 记录发送日志
        $stmt = $db->prepare("INSERT INTO message_logs (user_id, template_id, send_status, send_time) VALUES (?, ?, 'success', NOW())");
        $stmt->execute([$user['id'], $template_id]);
    } else {
        // 记录失败日志
        $stmt = $db->prepare("INSERT INTO message_logs (user_id, template_id, send_status, error_msg, send_time) VALUES (?, ?, 'failed', ?, NOW())");
        $stmt->execute([$user['id'], $template_id, $result['error']]);
    }
}

// 判断是否在工作时间内
function isWorkTime($work_start_time, $work_end_time) {
    $now = date('H:i');
    return $now >= $work_start_time && $now <= $work_end_time;
}

// 发送订阅消息
function sendSubscribeMessage($access_token, $openid, $template_id) {
    $url = "https://api.weixin.qq.com/cgi-bin/message/subscribe/send?access_token={$access_token}";
    
    $data = [
        'touser' => $openid,
        'template_id' => $template_id,
        'page' => 'pages/index/index',
        'data' => [
            'thing1' => ['value' => '久坐提醒'],
            'time2' => ['value' => date('Y年m月d日 H:i')],
            'thing3' => ['value' => '您已经坐了很久了，站起来活动一下吧！']
        ]
    ];
    
    $ch = curl_init();
    curl_setopt($ch, CURLOPT_URL, $url);
    curl_setopt($ch, CURLOPT_POST, true);
    curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($data));
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
    curl_setopt($ch, CURLOPT_HTTPHEADER, ['Content-Type: application/json']);
    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);
    $response = curl_exec($ch);
    curl_close($ch);
    
    $result = json_decode($response, true);
    
    if (isset($result['errcode']) && $result['errcode'] == 0) {
        return ['success' => true];
    } else {
        return [
            'success' => false,
            'error' => $result['errmsg'] ?? '未知错误'
        ];
    }
}

// 获取微信 access_token（带缓存）
function getWechatAccessToken() {
    // 从缓存读取
    $cache_file = '../cache/access_token.json';
    if (file_exists($cache_file)) {
        $cache = json_decode(file_get_contents($cache_file), true);
        if ($cache && time() < $cache['expires_at']) {
            return $cache['access_token'];
        }
    }
    
    // 重新获取
    $appid = WECHAT_APPID;
    $secret = WECHAT_SECRET;
    $url = "https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid={$appid}&secret={$secret}";
    
    $ch = curl_init();
    curl_setopt($ch, CURLOPT_URL, $url);
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);
    $response = curl_exec($ch);
    curl_close($ch);
    
    $result = json_decode($response, true);
    
    if (isset($result['access_token'])) {
        // 缓存 access_token（提前5分钟过期）
        $cache = [
            'access_token' => $result['access_token'],
            'expires_at' => time() + $result['expires_in'] - 300
        ];
        file_put_contents($cache_file, json_encode($cache));
        return $result['access_token'];
    }
    
    throw new Exception('获取access_token失败');
}
```

### 4. JWT Token 工具类

```php
<?php
// utils/jwt.php

define('JWT_SECRET', 'your-secret-key-here'); // 请修改为随机字符串

function generateJWT($payload) {
    $header = [
        'typ' => 'JWT',
        'alg' => 'HS256'
    ];
    
    $payload['iat'] = time();
    $payload['exp'] = time() + 7200; // 2小时过期
    
    $header_encoded = base64UrlEncode(json_encode($header));
    $payload_encoded = base64UrlEncode(json_encode($payload));
    
    $signature = hash_hmac('sha256', "$header_encoded.$payload_encoded", JWT_SECRET, true);
    $signature_encoded = base64UrlEncode($signature);
    
    return "$header_encoded.$payload_encoded.$signature_encoded";
}

function verifyJWT($token) {
    $parts = explode('.', $token);
    if (count($parts) !== 3) {
        return false;
    }
    
    list($header_encoded, $payload_encoded, $signature_encoded) = $parts;
    
    $signature = base64UrlDecode($signature_encoded);
    $expected_signature = hash_hmac('sha256', "$header_encoded.$payload_encoded", JWT_SECRET, true);
    
    if (!hash_equals($signature, $expected_signature)) {
        return false;
    }
    
    $payload = json_decode(base64UrlDecode($payload_encoded), true);
    
    if ($payload['exp'] < time()) {
        return false; // token已过期
    }
    
    return $payload;
}

function base64UrlEncode($data) {
    return rtrim(strtr(base64_encode($data), '+/', '-_'), '=');
}

function base64UrlDecode($data) {
    return base64_decode(strtr($data, '-_', '+/'));
}
```

### 5. 认证中间件

```php
<?php
// utils/auth.php

require_once 'jwt.php';

function verifyToken() {
    $headers = getallheaders();
    $auth_header = $headers['Authorization'] ?? $headers['authorization'] ?? '';
    
    if (empty($auth_header)) {
        return false;
    }
    
    if (preg_match('/Bearer\s+(.*)$/i', $auth_header, $matches)) {
        $token = $matches[1];
        return verifyJWT($token);
    }
    
    return false;
}

function getBearerToken() {
    $headers = getallheaders();
    $auth_header = $headers['Authorization'] ?? $headers['authorization'] ?? '';
    
    if (preg_match('/Bearer\s+(.*)$/i', $auth_header, $matches)) {
        return $matches[1];
    }
    
    return null;
}
```

## 三、配置文件示例

```php
<?php
// config.php

// 数据库配置
define('DB_HOST', 'localhost');
define('DB_NAME', 'standup_app');
define('DB_USER', 'root');
define('DB_PASS', 'password');
define('DB_CHARSET', 'utf8mb4');

// 微信配置
define('WECHAT_APPID', 'your_appid');
define('WECHAT_SECRET', 'your_secret');

// JWT配置
define('JWT_SECRET', 'your-jwt-secret-key');

// 时区设置
date_default_timezone_set('Asia/Shanghai');
```

## 四、定时任务配置

### Docker 容器中的定时任务配置

项目已配置 Docker 容器内的定时任务，通过 crond 服务实现：

1. **配置文件位置**: `conf/crontab`
   ```bash
   # 每5分钟执行一次提醒任务
   */5 * * * * curl -s http://localhost/cron/send-remind > /dev/null 2>&1
   ```

2. **启动方式**: 容器启动时自动加载定时任务并启动 crond 服务（见 `run.sh`）

3. **执行方式**: 通过 HTTP 请求调用内部接口 `/cron/send-remind`，触发 `Cron::sendRemind()` 方法

### Linux Crontab 配置（非 Docker 环境）

```bash
# 每5分钟执行一次提醒任务
*/5 * * * * curl -s https://sofun.online/cron/send-remind > /dev/null 2>&1
```

### 或者使用 PHP 定时任务框架

推荐使用 Laravel 的 Task Scheduler 或其他 PHP 定时任务框架。

## 五、注意事项

1. **安全性**:
   - JWT_SECRET 要使用随机字符串，不要泄露
   - 所有用户输入都要验证和过滤
   - 使用 PDO 预处理语句防止 SQL 注入

2. **性能**:
   - access_token 要缓存，避免频繁请求
   - 数据库查询要使用索引
   - 可以考虑使用 Redis 缓存统计数据

3. **错误处理**:
   - 所有接口都要有错误处理
   - 记录错误日志
   - 微信接口调用失败要有重试机制

4. **测试**:
   - 在开发环境充分测试
   - 使用微信开发者工具测试
   - 测试各种异常情况

